from fastapi import FastAPI, Request, Form
from fastapi.responses import HTMLResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
import httpx, re
from bs4 import BeautifulSoup

app = FastAPI(title="Bassam App", version="1.2")

# Ø±Ø¨Ø· Ø§Ù„Ù‚ÙˆØ§Ù„Ø¨ ÙˆØ§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ø«Ø§Ø¨ØªØ©
app.mount("/static", StaticFiles(directory="static"), name="static")
templates = Jinja2Templates(directory="templates")

# ===================== 1) Ù…Ø­ÙˆÙ‘Ù„Ø§Øª Ø§Ù„ÙˆØ­Ø¯Ø§Øª (Ø£ÙˆØ²Ø§Ù† + Ø£Ø·ÙˆØ§Ù„ + Ø£Ø­Ø¬Ø§Ù…) =====================

AR_NUM = str.maketrans("Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©", "0123456789")

def _to_float(s: str):
    s = (s or "").strip().translate(AR_NUM).replace(",", "")
    try: return float(s)
    except: return None

# ---- Ø§Ù„Ø£ÙˆØ²Ø§Ù† (Ø£Ø³Ø§Ø³ Ø§Ù„ØªØ­ÙˆÙŠÙ„ = ÙƒÙŠÙ„ÙˆØºØ±Ø§Ù…) ----
WEIGHT_ALIASES = {
    "ÙƒÙŠÙ„Ùˆ": "kg", "ÙƒÙŠÙ„ÙˆØ¬Ø±Ø§Ù…": "kg", "ÙƒØ¬Ù…": "kg", "ÙƒØº": "kg", "kg": "kg",
    "Ø¬Ø±Ø§Ù…": "g", "Øº": "g", "g": "g",
    "Ù…Ù„ØºÙ…": "mg", "Ù…ÙŠÙ„ÙŠØºØ±Ø§Ù…": "mg", "mg": "mg",
    "Ø±Ø·Ù„": "lb", "Ø¨Ø§ÙˆÙ†Ø¯": "lb", "lb": "lb",
    "Ø£ÙˆÙ‚ÙŠØ©": "oz", "Ø§ÙˆÙ†ØµØ©": "oz", "oz": "oz",
    "Ø·Ù†": "t", "Ø·Ù† Ù…ØªØ±ÙŠ": "t", "t": "t",
}
W_TO_KG = {"kg":1.0, "g":0.001, "mg":1e-6, "lb":0.45359237, "oz":0.028349523125, "t":1000.0}

# ---- Ø§Ù„Ø£Ø·ÙˆØ§Ù„ (Ø£Ø³Ø§Ø³ Ø§Ù„ØªØ­ÙˆÙŠÙ„ = Ù…ØªØ±) ----
LENGTH_ALIASES = {
    "Ù…Ù…": "mm", "Ù…ÙŠÙ„ÙŠÙ…ØªØ±": "mm", "mm": "mm",
    "Ø³Ù…": "cm", "Ø³Ù†ØªÙŠÙ…ØªØ±": "cm", "cm": "cm",
    "Ù…": "m", "Ù…ØªØ±": "m", "m": "m",
    "ÙƒÙ…": "km", "ÙƒÙŠÙ„ÙˆÙ…ØªØ±": "km", "km": "km",
    "Ø¥Ù†Ø´": "in", "Ø¨ÙˆØµØ©": "in", "Ø§Ù†Ø´": "in", "inch": "in", "in": "in",
    "Ù‚Ø¯Ù…": "ft", "Ù‚Ø¯Ù…Ù‹Ø§": "ft", "Ù‚Ø¯Ù…ÙŠØ©": "ft", "ft": "ft",
    "ÙŠØ§Ø±Ø¯Ø©": "yd", "ÙŠØ§Ø±Ø¯": "yd", "yd": "yd",
    "Ù…ÙŠÙ„": "mi", "mi": "mi",
}
L_TO_M = {
    "mm":0.001, "cm":0.01, "m":1.0, "km":1000.0,
    "in":0.0254, "ft":0.3048, "yd":0.9144, "mi":1609.344
}

# ---- Ø§Ù„Ø£Ø­Ø¬Ø§Ù… (Ø£Ø³Ø§Ø³ Ø§Ù„ØªØ­ÙˆÙŠÙ„ = Ù„ØªØ±) ----
VOLUME_ALIASES = {
    "Ù…Ù„": "ml", "Ù…Ù„Ù„": "ml", "Ù…Ù„Ù„ÙŠÙ„ØªØ±": "ml", "ml": "ml",
    "Ù„": "l", "Ù„ØªØ±": "l", "lt": "l", "l": "l",
    "ÙƒÙˆØ¨": "cup", "ÙƒØ§Ø³Ø©": "cup", "cup": "cup",
    "Ù…Ù„Ø¹Ù‚Ø©": "tbsp", "Ù…Ù„Ø¹Ù‚Ø© ÙƒØ¨ÙŠØ±Ø©": "tbsp", "tbsp": "tbsp",
    "Ù…Ù„Ø¹Ù‚Ø© ØµØºÙŠØ±Ø©": "tsp", "tsp": "tsp",
    "ØºØ§Ù„ÙˆÙ†": "gal", "Ø¬Ø§Ù„ÙˆÙ†": "gal", "gal": "gal",
    "Ø¨Ø§ÙŠÙ†Øª": "pt", "pint": "pt", "pt": "pt",
    "ÙƒÙˆØ§Ø±Øª": "qt", "quart": "qt", "qt": "qt",
}
V_TO_L = {
    "ml": 0.001, "l": 1.0,
    "cup": 0.2365882365, "tbsp": 0.0147867648, "tsp": 0.0049289216,
    "gal": 3.785411784, "pt": 0.473176473, "qt": 0.946352946
}

# ØªØ¬Ù…ÙŠØ¹ Ø§Ù„Ù‚ÙˆØ§Ù…ÙŠØ³ Ù„ÙØ­Øµ Ù†ÙˆØ¹ Ø§Ù„ÙˆØ­Ø¯Ø©
ALL_ALIASES = {**WEIGHT_ALIASES, **LENGTH_ALIASES, **VOLUME_ALIASES}
TYPE_OF_UNIT = {}
for k, v in WEIGHT_ALIASES.items(): TYPE_OF_UNIT[v] = "W"
for k, v in LENGTH_ALIASES.items(): TYPE_OF_UNIT[v] = "L"
for k, v in VOLUME_ALIASES.items(): TYPE_OF_UNIT[v] = "V"

def _norm_unit(u: str):
    u = (u or "").strip().lower().translate(AR_NUM)
    return ALL_ALIASES.get(u, "")

# Ø£Ù†Ù…Ø§Ø· Ø¹Ø±Ø¨ÙŠØ© Ø´Ø§Ø¦Ø¹Ø©: "70 ÙƒÙŠÙ„Ùˆ Ø¥Ù„Ù‰ Ø±Ø·Ù„" / "500 ØºØ±Ø§Ù… ÙƒÙ… Ø£ÙˆÙ‚ÙŠØ©" / "1 Ø·Ù† ÙŠØ³Ø§ÙˆÙŠ ÙƒÙ… ÙƒÙŠÙ„Ùˆ" / "ÙƒÙ… ÙŠØ³Ø§ÙˆÙŠ 2 Ù…ØªØ± Ø¨Ø§Ù„Ù‚Ø¯Ù…"
CONV_RE = re.compile(
    r'(?:ÙƒÙ…\s*ÙŠØ³Ø§ÙˆÙŠ\s*)?([\d\.,]+)\s*(\S+)\s*(?:Ø¥Ù„Ù‰|Ù„|=|ÙŠØ³Ø§ÙˆÙŠ|Ø¨Ø§Ù„|Ø¨Ù€)\s*(\S+)',
    re.IGNORECASE
)

def convert_query_ar(query: str):
    """
    ÙŠØ­Ø§ÙˆÙ„ ÙÙ‡Ù… Ø§Ù„Ø³Ø¤Ø§Ù„ ÙˆØªØ­ÙˆÙŠÙ„Ù‡. ÙŠØ±Ø¬Ø¹ dict ÙÙŠÙ‡ Ù†Øµ + HTML Ø¥Ù† Ù†Ø¬Ø­ØŒ Ø£Ùˆ None Ø¥Ù† Ù„Ù… ÙŠÙƒÙ† ØªØ­ÙˆÙŠÙ„Ù‹Ø§.
    """
    q = (query or "").strip()
    m = CONV_RE.search(q)
    if not m:
        return None
    val_s, u_from_s, u_to_s = m.groups()
    value = _to_float(val_s)
    u_from = _norm_unit(u_from_s)
    u_to   = _norm_unit(u_to_s)
    if value is None or not u_from or not u_to:
        return None

    # Ù†ÙˆØ¹ Ø§Ù„ÙˆØ­Ø¯Ø© (ÙˆØ²Ù†/Ø·ÙˆÙ„/Ø­Ø¬Ù…) ÙŠØ¬Ø¨ Ø£Ù† ÙŠØªØ·Ø§Ø¨Ù‚
    t_from = TYPE_OF_UNIT.get(u_from)
    t_to   = TYPE_OF_UNIT.get(u_to)
    if not t_from or t_from != t_to:
        return None  # Ù„Ø§ Ù†Ø­ÙˆÙ„ ÙˆØ²Ù† Ø¥Ù„Ù‰ Ø·ÙˆÙ„ Ù…Ø«Ù„Ù‹Ø§

    # ØªØ­ÙˆÙŠÙ„ Ø­Ø³Ø¨ Ø§Ù„Ù†ÙˆØ¹
    if t_from == "W":
        kg = value * W_TO_KG[u_from]
        res = kg / W_TO_KG[u_to]
    elif t_from == "L":
        m = value * L_TO_M[u_from]
        res = m / L_TO_M[u_to]
    else:  # "V"
        l = value * V_TO_L[u_from]
        res = l / V_TO_L[u_to]

    text = f"{value:g} {u_from_s} â‰ˆ {res:,.6f} {u_to_s}"
    html = f'<div class="card"><strong>Ø§Ù„Ù†ØªÙŠØ¬Ø©:</strong> {text}</div>'
    return {"text": text, "html": html}

# ===================== 2) ÙˆØ§Ø¬Ù‡Ø© HTML =====================

@app.get("/", response_class=HTMLResponse)
async def home(request: Request):
    return templates.TemplateResponse("index.html", {"request": request})

# Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
@app.post("/", response_class=HTMLResponse)
async def run(request: Request, question: str = Form(...), mode: str = Form("summary")):
    q = (question or "").strip()
    answer_text = ""
    result_panel = ""

    # Ø£ÙˆÙ„Ù‹Ø§: Ø­Ø§ÙˆÙ„ Ù…Ø­ÙˆÙ‘Ù„ Ø§Ù„ÙˆØ­Ø¯Ø§Øª (Ø£ÙˆØ²Ø§Ù†/Ø£Ø·ÙˆØ§Ù„/Ø£Ø­Ø¬Ø§Ù…)
    conv = convert_query_ar(q)
    if conv:
        return templates.TemplateResponse("index.html", {
            "request": request, "q": q, "mode": mode,
            "answer_text": conv["text"], "result_panel": conv["html"]
        })

    # Ø«Ø§Ù†ÙŠÙ‹Ø§: Ø¥Ù† Ù„Ù… ÙŠÙƒÙ† ØªØ­ÙˆÙŠÙ„ØŒ Ù†ÙØ° Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨
    try:
        async with httpx.AsyncClient(timeout=20) as client:
            r = await client.get("https://duckduckgo.com/html/", params={"q": q})
            soup = BeautifulSoup(r.text, "html.parser")
            snippets = [re.sub(r"\s+", " ", el.get_text()) for el in soup.select(".result__snippet")]
            links = [a.get("href") for a in soup.select(".result__a")]

        if mode == "summary":
            parts = []
            for s in snippets[:3]:
                parts.append(s)
            answer_text = " ".join(parts) if parts else "Ù„Ù… Ø£Ø¬Ø¯ Ù…Ù„Ø®ØµÙ‹Ø§ Ù…Ù†Ø§Ø³Ø¨Ù‹Ø§."
            result_panel = "<br>".join(parts) if parts else "Ù„Ù… Ø£Ø¬Ø¯ Ù…Ù„Ø®ØµÙ‹Ø§ Ù…Ù†Ø§Ø³Ø¨Ù‹Ø§."

        elif mode == "prices":
            parts = []
            for s, a in zip(snippets, links):
                if any(x in s for x in ["$", "USD", "SAR", "Ø±.Ø³", "AED", "Ø¯.Ø¥", "EGP", "Ø¬.Ù…"]):
                    parts.append(f"{s} â€” <a target='_blank' href='{a}'>ÙØªØ­ Ø§Ù„Ù…ØµØ¯Ø±</a>")
                if len(parts) >= 8:
                    break
            answer_text = BeautifulSoup("<br>".join(parts), "html.parser").get_text(" ")
            result_panel = "<br>".join(parts) if parts else "Ù„Ù… Ø£Ø¬Ø¯ Ø£Ø³Ø¹Ø§Ø±Ù‹Ø§ ÙˆØ§Ø¶Ø­Ø©Ø› Ø§ÙØªØ­ Ø§Ù„Ø±ÙˆØ§Ø¨Ø· Ù„Ù„ØªØ­Ù‚Ù‚."

        elif mode == "images":
            # Ø±Ø§Ø¨Ø· Ø³Ø±ÙŠØ¹ Ù„Ø¨Ø­Ø« Ø§Ù„ØµÙˆØ± (Ø­Ø± ÙˆÙ…Ø¨Ø§Ø´Ø±)
            result_panel = f"<div class='card'><a target='_blank' href='https://duckduckgo.com/?q={q}&iax=images&ia=images'>Ø§ÙØªØ­ Ù†ØªØ§Ø¦Ø¬ Ø§Ù„ØµÙˆØ± ğŸ”—</a></div>"
            answer_text = "Ù†ØªØ§Ø¦Ø¬ ØµÙˆØ± â€” Ø§ÙØªØ­ Ø§Ù„Ø±Ø§Ø¨Ø·."

        else:
            answer_text = "ÙˆØ¶Ø¹ ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ."
            result_panel = "ÙˆØ¶Ø¹ ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ."

    except Exception as e:
        answer_text = f"Ø­Ø¯Ø« Ø®Ø·Ø£: {e}"
        result_panel = answer_text

    return templates.TemplateResponse("index.html", {
        "request": request,
        "q": q,
        "mode": mode,
        "answer_text": answer_text,
        "result_panel": result_panel
    })

@app.get("/healthz")
async def healthz():
    return {"status": "ok"}